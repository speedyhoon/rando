package types

import (
	"bytes"
	"errors"
	"fmt"
	"github.com/speedyhoon/numnam"
	"strings"
)

// PackageSequence generates a Go main package a random struct with the given field types.
// It returns the package and test code required to test MarshalJ() & UnmarshalJ().
func PackageSequence(name string, typ, generatedBy string) (pkg, test []byte, err error) {
	generatedBy = strings.TrimSpace(generatedBy)
	if generatedBy == "" {
		generatedBy = "rando/types"
	}

	b := bytes.NewBufferString(fmt.Sprintf(`// Code generated by %s; DO NOT EDIT.

package %s

`, generatedBy, name))
	tests := bytes.NewBuffer(b.Bytes())
	tests.WriteString(`

import (
	"github.com/speedyhoon/rando"
	"github.com/stretchr/testify/require"
	"testing"
)

`)
	structs := bytes.NewBuffer(nil)
	typeNames := NumberList(23)
	for i, typeName := range typeNames {
		structLines, testLines := StructSequence(typeName, uint(i+1), typ)
		structs.Write(structLines)

		tests.WriteString(fmt.Sprintf(`
func TestFuzz_%[3]d(t *testing.T) {
	var expected, actual %[1]s
	require.NoError(t, expected.UnmarshalJ(actual.MarshalJ()))
	require.Equal(t, expected, actual)
	require.Equal(t, %[1]s{}, expected)
	require.Equal(t, %[1]s{}, actual)

	actual = %[1]s{
		%[2]s
	}
	src := actual.MarshalJ()
	require.NoError(t, expected.UnmarshalJ(src))
	//require.NotEqual(t, %[1]s{}, expected)
	//require.NotEqual(t, %[1]s{}, actual)
	require.Equal(t, expected, actual)
}
`, typeName, testLines, i+1))
	}

	if bytes.Contains(structs.Bytes(), []byte("time.Time")) {
		b.WriteString("import \"time\"\n\n")
	}
	b.Write(structs.Bytes())

	pkg, err1 := goFormat(b.Bytes())
	test, err2 := goFormat(tests.Bytes())

	return pkg, test, errors.Join(err1, err2)
}

// StructSequence generates a struct with random field names with the given types.
func StructSequence(name string, qty uint, typ string) (fields, testLines []byte) {
	b := bytes.NewBufferString(fmt.Sprintf("type %s struct{\n", name))
	tl := bytes.NewBuffer(nil)
	fieldNames := NumberList(qty)

	for _, n := range fieldNames {
		b.WriteString(n)
		b.WriteString("\t")
		b.WriteString(typ)
		b.WriteString("\n")

		// Test lines.
		tl.WriteString(n)
		tl.WriteString(":\t")
		tl.WriteString(TypeRandomFunc(typ))
		tl.WriteString(",\n")
	}
	b.WriteString("}\n\n")
	return b.Bytes(), tl.Bytes()
}

func NumberList(qty uint) (names []string) {
	names = make([]string, qty)
	for i := uint(0); i < qty; i++ {
		names[i] = numnam.ToWordU(i + 1)
	}
	return
}
